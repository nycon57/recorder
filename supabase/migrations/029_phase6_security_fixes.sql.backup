-- Phase 6 Security Fixes Migration
-- CRITICAL: Addresses 5 critical security vulnerabilities identified in audit

-- ============================================================================
-- 1. ADD SYSTEM ADMIN FLAG FOR PROPER AUTHORIZATION
-- ============================================================================

-- Add is_system_admin column to users table
ALTER TABLE users
ADD COLUMN IF NOT EXISTS is_system_admin BOOLEAN DEFAULT FALSE;

-- Add index for system admin queries
CREATE INDEX IF NOT EXISTS idx_users_system_admin
ON users(clerk_id)
WHERE is_system_admin = TRUE;

-- Add comment for documentation
COMMENT ON COLUMN users.is_system_admin IS 'SECURITY: System-wide admin flag. Only users with this flag can access system admin endpoints';

-- ============================================================================
-- 2. CREATE ATOMIC QUOTA CHECK FUNCTION TO PREVENT RACE CONDITIONS
-- ============================================================================

-- Drop existing function if exists
DROP FUNCTION IF EXISTS check_quota_optimized;

-- Create optimized atomic quota check and consume function
CREATE OR REPLACE FUNCTION check_quota_optimized(
    p_org_id UUID,
    p_quota_type TEXT,
    p_amount INTEGER DEFAULT 1
)
RETURNS BOOLEAN AS $$
DECLARE
    v_quota RECORD;
    v_allowed BOOLEAN := FALSE;
    v_current_usage INTEGER;
    v_limit INTEGER;
BEGIN
    -- SECURITY: Use FOR UPDATE SKIP LOCKED to prevent race conditions
    -- This ensures only one transaction can modify quota at a time
    SELECT * INTO v_quota
    FROM org_quotas
    WHERE org_id = p_org_id
    FOR UPDATE SKIP LOCKED;

    -- If no quota found or locked, deny access
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- Check if quota needs reset
    IF v_quota.quota_reset_at < NOW() THEN
        -- Reset monthly quotas
        UPDATE org_quotas
        SET
            searches_used = 0,
            recordings_used = 0,
            ai_requests_used = 0,
            quota_reset_at = DATE_TRUNC('month', NOW() + INTERVAL '1 month')
        WHERE org_id = p_org_id;

        -- Refetch after reset
        SELECT * INTO v_quota
        FROM org_quotas
        WHERE org_id = p_org_id;
    END IF;

    -- Check and consume quota based on type
    CASE p_quota_type
        WHEN 'search' THEN
            v_current_usage := v_quota.searches_used;
            v_limit := v_quota.searches_per_month;

            IF (v_current_usage + p_amount) <= v_limit THEN
                UPDATE org_quotas
                SET searches_used = searches_used + p_amount
                WHERE org_id = p_org_id;
                v_allowed := TRUE;
            END IF;

        WHEN 'recording' THEN
            v_current_usage := v_quota.recordings_used;
            v_limit := v_quota.recordings_per_month;

            IF (v_current_usage + p_amount) <= v_limit THEN
                UPDATE org_quotas
                SET recordings_used = recordings_used + p_amount
                WHERE org_id = p_org_id;
                v_allowed := TRUE;
            END IF;

        WHEN 'ai' THEN
            v_current_usage := v_quota.ai_requests_used;
            v_limit := v_quota.ai_requests_per_month;

            IF (v_current_usage + p_amount) <= v_limit THEN
                UPDATE org_quotas
                SET ai_requests_used = ai_requests_used + p_amount
                WHERE org_id = p_org_id;
                v_allowed := TRUE;
            END IF;

        WHEN 'connector' THEN
            v_current_usage := v_quota.connectors_used;
            v_limit := v_quota.connectors_allowed;

            IF (v_current_usage + p_amount) <= v_limit THEN
                UPDATE org_quotas
                SET connectors_used = connectors_used + p_amount
                WHERE org_id = p_org_id;
                v_allowed := TRUE;
            END IF;

        WHEN 'storage' THEN
            v_current_usage := CEIL(v_quota.storage_used_gb);
            v_limit := v_quota.storage_gb;

            IF (v_current_usage + p_amount) <= v_limit THEN
                -- Storage is updated separately via updateStorageUsage
                v_allowed := TRUE;
            END IF;

        ELSE
            -- Unknown quota type
            v_allowed := FALSE;
    END CASE;

    RETURN v_allowed;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add comment for documentation
COMMENT ON FUNCTION check_quota_optimized IS 'SECURITY: Atomic quota check and consume to prevent race conditions. Always use this instead of separate check/consume operations.';

-- ============================================================================
-- 3. ADD UUID VALIDATION FUNCTION FOR SQL INJECTION PREVENTION
-- ============================================================================

-- Create UUID validation function
CREATE OR REPLACE FUNCTION is_valid_uuid(input_text TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- Attempt to cast to UUID
    PERFORM input_text::UUID;
    RETURN TRUE;
EXCEPTION WHEN invalid_text_representation THEN
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

-- Add comment for documentation
COMMENT ON FUNCTION is_valid_uuid IS 'SECURITY: Validates UUID format to prevent SQL injection in dynamic queries';

-- ============================================================================
-- 4. CREATE QUOTA USAGE EVENTS TABLE (IF NOT EXISTS)
-- ============================================================================

CREATE TABLE IF NOT EXISTS quota_usage_events (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    quota_type TEXT NOT NULL,
    amount INTEGER NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Indexes for performance
    CONSTRAINT quota_usage_events_quota_type_check
        CHECK (quota_type IN ('search', 'recording', 'ai', 'connector', 'storage'))
);

-- Create indexes if not exists
CREATE INDEX IF NOT EXISTS idx_quota_usage_events_org_id
ON quota_usage_events(org_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_quota_usage_events_type
ON quota_usage_events(quota_type, created_at DESC);

-- ============================================================================
-- 5. ADD SECURITY AUDIT LOG TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS security_audit_log (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    event_type TEXT NOT NULL,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    org_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
    ip_address INET,
    user_agent TEXT,
    details JSONB,
    severity TEXT DEFAULT 'info',
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints
    CONSTRAINT security_audit_log_event_type_check
        CHECK (event_type IN ('unauthorized_access', 'rate_limit_exceeded', 'quota_exceeded',
                              'invalid_input', 'system_admin_access', 'suspicious_activity')),
    CONSTRAINT security_audit_log_severity_check
        CHECK (severity IN ('info', 'warning', 'error', 'critical'))
);

-- Create indexes for audit log queries
CREATE INDEX IF NOT EXISTS idx_security_audit_log_user
ON security_audit_log(user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_security_audit_log_org
ON security_audit_log(org_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_security_audit_log_severity
ON security_audit_log(severity, created_at DESC)
WHERE severity IN ('error', 'critical');

-- ============================================================================
-- 6. UPDATE RLS POLICIES FOR SECURITY TABLES
-- ============================================================================

-- Enable RLS on new tables
ALTER TABLE quota_usage_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_audit_log ENABLE ROW LEVEL SECURITY;

-- Quota usage events policies
CREATE POLICY "Organizations can view their own quota usage"
ON quota_usage_events FOR SELECT
USING (
    org_id IN (
        SELECT org_id FROM users
        WHERE clerk_id = auth.jwt() ->> 'sub'
    )
);

-- Security audit log policies (system admins only)
CREATE POLICY "System admins can view all audit logs"
ON security_audit_log FOR ALL
USING (
    EXISTS (
        SELECT 1 FROM users
        WHERE clerk_id = auth.jwt() ->> 'sub'
        AND is_system_admin = TRUE
    )
);

-- ============================================================================
-- 7. CREATE FUNCTION TO LOG SECURITY EVENTS
-- ============================================================================

CREATE OR REPLACE FUNCTION log_security_event(
    p_event_type TEXT,
    p_user_id UUID DEFAULT NULL,
    p_org_id UUID DEFAULT NULL,
    p_details JSONB DEFAULT NULL,
    p_severity TEXT DEFAULT 'info'
)
RETURNS UUID AS $$
DECLARE
    v_event_id UUID;
BEGIN
    INSERT INTO security_audit_log (
        event_type,
        user_id,
        org_id,
        details,
        severity
    ) VALUES (
        p_event_type,
        p_user_id,
        p_org_id,
        p_details,
        p_severity
    ) RETURNING id INTO v_event_id;

    RETURN v_event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 8. ADD CONSTRAINTS FOR DATA INTEGRITY
-- ============================================================================

-- Ensure org_quotas has proper constraints
ALTER TABLE org_quotas
ADD CONSTRAINT check_positive_limits CHECK (
    searches_per_month >= 0 AND
    storage_gb >= 0 AND
    recordings_per_month >= 0 AND
    ai_requests_per_month >= 0 AND
    connectors_allowed >= 0
);

ALTER TABLE org_quotas
ADD CONSTRAINT check_usage_not_negative CHECK (
    searches_used >= 0 AND
    storage_used_gb >= 0 AND
    recordings_used >= 0 AND
    ai_requests_used >= 0 AND
    connectors_used >= 0
);

-- ============================================================================
-- 9. GRANT NECESSARY PERMISSIONS
-- ============================================================================

-- Grant execute permission on security functions to authenticated users
GRANT EXECUTE ON FUNCTION check_quota_optimized TO authenticated;
GRANT EXECUTE ON FUNCTION is_valid_uuid TO authenticated;
GRANT EXECUTE ON FUNCTION log_security_event TO authenticated;

-- ============================================================================
-- DATA MIGRATION: Set initial system admins (customize as needed)
-- ============================================================================

-- Example: Set specific users as system admins by their email
-- UPDATE users
-- SET is_system_admin = TRUE
-- WHERE email IN ('admin@example.com');

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================

-- Verify system admin column exists
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users'
        AND column_name = 'is_system_admin'
    ) THEN
        RAISE NOTICE 'SUCCESS: is_system_admin column added to users table';
    ELSE
        RAISE EXCEPTION 'FAILED: is_system_admin column not found';
    END IF;
END $$;

-- Verify check_quota_optimized function exists
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_proc
        WHERE proname = 'check_quota_optimized'
    ) THEN
        RAISE NOTICE 'SUCCESS: check_quota_optimized function created';
    ELSE
        RAISE EXCEPTION 'FAILED: check_quota_optimized function not found';
    END IF;
END $$;

-- Verify security tables exist
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_name IN ('quota_usage_events', 'security_audit_log')
    ) THEN
        RAISE NOTICE 'SUCCESS: Security tables created';
    ELSE
        RAISE EXCEPTION 'FAILED: Security tables not found';
    END IF;
END $$;

-- Log migration completion
INSERT INTO security_audit_log (
    event_type,
    details,
    severity
) VALUES (
    'system_admin_access',
    jsonb_build_object(
        'action', 'security_fixes_migration',
        'version', '029',
        'fixes_applied', ARRAY[
            'System admin authorization',
            'Atomic quota checks',
            'UUID validation',
            'Security audit logging',
            'Data integrity constraints'
        ]
    ),
    'info'
);

-- ============================================================================
-- END OF SECURITY FIXES MIGRATION
-- ============================================================================
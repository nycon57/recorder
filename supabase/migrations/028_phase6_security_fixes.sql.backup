-- ============================================
-- PHASE 6 SECURITY FIXES
-- Addresses critical RLS and security issues found in audit
-- ============================================

-- ============================================
-- FIX 1: ENABLE RLS ON PARTITION TABLES
-- PostgreSQL partitions DO NOT inherit RLS from parent table
-- ============================================

ALTER TABLE search_analytics_2025_10 ENABLE ROW LEVEL SECURITY;
ALTER TABLE search_analytics_2025_11 ENABLE ROW LEVEL SECURITY;
ALTER TABLE search_analytics_2025_12 ENABLE ROW LEVEL SECURITY;
ALTER TABLE search_analytics_2026_01 ENABLE ROW LEVEL SECURITY;

-- Create policies for each partition (must be done individually)
-- Partition: 2025_10
DROP POLICY IF EXISTS "Users can view their org's analytics" ON search_analytics_2025_10;
CREATE POLICY "Users can view their org's analytics" ON search_analytics_2025_10
  FOR SELECT USING (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

DROP POLICY IF EXISTS "Users can insert their org's analytics" ON search_analytics_2025_10;
CREATE POLICY "Users can insert their org's analytics" ON search_analytics_2025_10
  FOR INSERT WITH CHECK (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

-- Partition: 2025_11
DROP POLICY IF EXISTS "Users can view their org's analytics" ON search_analytics_2025_11;
CREATE POLICY "Users can view their org's analytics" ON search_analytics_2025_11
  FOR SELECT USING (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

DROP POLICY IF EXISTS "Users can insert their org's analytics" ON search_analytics_2025_11;
CREATE POLICY "Users can insert their org's analytics" ON search_analytics_2025_11
  FOR INSERT WITH CHECK (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

-- Partition: 2025_12
DROP POLICY IF EXISTS "Users can view their org's analytics" ON search_analytics_2025_12;
CREATE POLICY "Users can view their org's analytics" ON search_analytics_2025_12
  FOR SELECT USING (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

DROP POLICY IF EXISTS "Users can insert their org's analytics" ON search_analytics_2025_12;
CREATE POLICY "Users can insert their org's analytics" ON search_analytics_2025_12
  FOR INSERT WITH CHECK (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

-- Partition: 2026_01
DROP POLICY IF EXISTS "Users can view their org's analytics" ON search_analytics_2026_01;
CREATE POLICY "Users can view their org's analytics" ON search_analytics_2026_01
  FOR SELECT USING (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

DROP POLICY IF EXISTS "Users can insert their org's analytics" ON search_analytics_2026_01;
CREATE POLICY "Users can insert their org's analytics" ON search_analytics_2026_01
  FOR INSERT WITH CHECK (org_id IN (SELECT org_id FROM users WHERE id = auth.uid()));

-- ============================================
-- FIX 2: ENABLE RLS ON BACKEND-ONLY TABLES
-- These tables contain org-scoped data and should be protected
-- ============================================

-- Quota usage events (org-scoped, no direct user access needed)
ALTER TABLE quota_usage_events ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service role can manage quota events" ON quota_usage_events;
CREATE POLICY "Service role can manage quota events" ON quota_usage_events
  FOR ALL USING (true);

COMMENT ON TABLE quota_usage_events IS 'Backend-only table. RLS enabled but allows service role full access.';

-- A/B Testing tables (admin/backend access only)
ALTER TABLE ab_experiments ENABLE ROW LEVEL SECURITY;
ALTER TABLE ab_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE ab_metrics ENABLE ROW LEVEL SECURITY;

-- Allow service role full access to A/B testing tables
DROP POLICY IF EXISTS "Service role manages experiments" ON ab_experiments;
CREATE POLICY "Service role manages experiments" ON ab_experiments
  FOR ALL USING (true);

DROP POLICY IF EXISTS "Service role manages assignments" ON ab_assignments;
CREATE POLICY "Service role manages assignments" ON ab_assignments
  FOR ALL USING (true);

DROP POLICY IF EXISTS "Service role manages metrics" ON ab_metrics;
CREATE POLICY "Service role manages metrics" ON ab_metrics
  FOR ALL USING (true);

-- Users can view their own experiment assignment
DROP POLICY IF EXISTS "Users can view their assignment" ON ab_assignments;
CREATE POLICY "Users can view their assignment" ON ab_assignments
  FOR SELECT USING (
    user_id = auth.uid() OR
    (user_id IS NULL AND org_id IN (SELECT org_id FROM users WHERE id = auth.uid()))
  );

COMMENT ON TABLE ab_experiments IS 'Backend-only table for A/B testing. RLS enabled with service role access.';
COMMENT ON TABLE ab_assignments IS 'A/B test assignments. Users can view their own, service role manages.';
COMMENT ON TABLE ab_metrics IS 'Backend-only metrics collection. RLS enabled with service role access.';

-- System metrics and alerting (admin-only)
ALTER TABLE system_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE alert_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE alert_incidents ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Service role manages system metrics" ON system_metrics;
CREATE POLICY "Service role manages system metrics" ON system_metrics
  FOR ALL USING (true);

DROP POLICY IF EXISTS "Service role manages alert rules" ON alert_rules;
CREATE POLICY "Service role manages alert rules" ON alert_rules
  FOR ALL USING (true);

DROP POLICY IF EXISTS "Service role manages alert incidents" ON alert_incidents;
CREATE POLICY "Service role manages alert incidents" ON alert_incidents
  FOR ALL USING (true);

-- Admins can view alert incidents (if we add role checking later)
DROP POLICY IF EXISTS "Admins can view incidents" ON alert_incidents;
CREATE POLICY "Admins can view incidents" ON alert_incidents
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE id = auth.uid()
      AND role IN ('owner', 'admin')
    )
  );

COMMENT ON TABLE system_metrics IS 'Backend-only system metrics. RLS enabled with service role access.';
COMMENT ON TABLE alert_rules IS 'Backend-only alert configuration. RLS enabled with service role access.';
COMMENT ON TABLE alert_incidents IS 'Alert incidents. Admins can view, service role manages.';

-- ============================================
-- FIX 3: CREATE MISSING MATERIALIZED VIEW
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS popular_queries AS
SELECT
  org_id,
  query,
  COUNT(*) as query_count,
  AVG(latency_ms) as avg_latency,
  AVG(results_count) as avg_results,
  COUNT(DISTINCT user_id) as unique_users,
  SUM(CASE WHEN cache_hit THEN 1 ELSE 0 END)::FLOAT / COUNT(*) as cache_hit_rate
FROM search_analytics
WHERE created_at > now() - INTERVAL '30 days'
GROUP BY org_id, query
HAVING COUNT(*) > 3
ORDER BY query_count DESC;

CREATE UNIQUE INDEX IF NOT EXISTS idx_popular_queries_org_query ON popular_queries(org_id, query);

COMMENT ON MATERIALIZED VIEW popular_queries IS 'Top search queries per org over last 30 days. Refresh daily via cron.';

-- ============================================
-- FIX 4: CREATE MISSING REFRESH FUNCTION
-- ============================================

CREATE OR REPLACE FUNCTION refresh_popular_queries()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.popular_queries;
END;
$$;

COMMENT ON FUNCTION refresh_popular_queries IS 'Refreshes popular_queries materialized view. Should be called daily via cron.';

-- ============================================
-- FIX 5: ADD search_path SECURITY TO PHASE 6 FUNCTIONS
-- ============================================

-- Update check_quota with search_path security
CREATE OR REPLACE FUNCTION check_quota(
  p_org_id UUID,
  p_quota_type TEXT,
  p_amount INTEGER DEFAULT 1
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_quota public.org_quotas%ROWTYPE;
  v_available INTEGER;
BEGIN
  SELECT * INTO v_quota FROM public.org_quotas WHERE org_id = p_org_id FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Quota not found for org %', p_org_id;
  END IF;

  IF v_quota.quota_reset_at < now() THEN
    UPDATE public.org_quotas SET
      searches_used = 0,
      recordings_used = 0,
      ai_requests_used = 0,
      quota_reset_at = date_trunc('month', now()) + INTERVAL '1 month'
    WHERE org_id = p_org_id;

    SELECT * INTO v_quota FROM public.org_quotas WHERE org_id = p_org_id;
  END IF;

  CASE p_quota_type
    WHEN 'search' THEN
      v_available := v_quota.searches_per_month - v_quota.searches_used;
      IF v_available >= p_amount THEN
        UPDATE public.org_quotas SET searches_used = searches_used + p_amount WHERE org_id = p_org_id;
        RETURN TRUE;
      END IF;
    WHEN 'recording' THEN
      v_available := v_quota.recordings_per_month - v_quota.recordings_used;
      IF v_available >= p_amount THEN
        UPDATE public.org_quotas SET recordings_used = recordings_used + p_amount WHERE org_id = p_org_id;
        RETURN TRUE;
      END IF;
    WHEN 'ai' THEN
      v_available := v_quota.ai_requests_per_month - v_quota.ai_requests_used;
      IF v_available >= p_amount THEN
        UPDATE public.org_quotas SET ai_requests_used = ai_requests_used + p_amount WHERE org_id = p_org_id;
        RETURN TRUE;
      END IF;
    ELSE
      RAISE EXCEPTION 'Unknown quota type: %', p_quota_type;
  END CASE;

  RETURN FALSE;
END;
$$;

-- Update delete_expired_search_history with search_path security
CREATE OR REPLACE FUNCTION delete_expired_search_history()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  DELETE FROM public.search_history WHERE expires_at < now();
END;
$$;

-- ============================================
-- FIX 6: UPDATE QUOTA DEFAULTS FOR EXISTING ORGS
-- Align with schema defaults (more generous than initial migration)
-- ============================================

UPDATE org_quotas SET
  searches_per_month = 1000,
  storage_gb = 10,
  recordings_per_month = 50,
  ai_requests_per_month = 500,
  connectors_allowed = 2
WHERE plan_tier = 'free';

COMMENT ON TABLE org_quotas IS 'Organization usage quotas. Free tier: 1000 searches, 10GB storage, 50 recordings, 500 AI requests, 2 connectors per month.';

-- ============================================
-- VERIFICATION QUERIES
-- Run these to verify fixes
-- ============================================

-- Check RLS is enabled on all Phase 6 tables
DO $$
DECLARE
  missing_rls TEXT[];
BEGIN
  SELECT array_agg(tablename)
  INTO missing_rls
  FROM pg_tables
  WHERE schemaname = 'public'
    AND tablename IN (
      'search_analytics', 'search_analytics_2025_10', 'search_analytics_2025_11',
      'search_analytics_2025_12', 'search_analytics_2026_01',
      'search_feedback', 'saved_searches', 'search_history', 'result_annotations',
      'org_quotas', 'quota_usage_events', 'ab_experiments', 'ab_assignments',
      'ab_metrics', 'system_metrics', 'alert_rules', 'alert_incidents'
    )
    AND tablename NOT IN (
      SELECT tablename FROM pg_tables t
      JOIN pg_class c ON c.relname = t.tablename
      WHERE c.relrowsecurity = true
    );

  IF array_length(missing_rls, 1) > 0 THEN
    RAISE WARNING 'Tables without RLS: %', missing_rls;
  ELSE
    RAISE NOTICE 'All Phase 6 tables have RLS enabled ✓';
  END IF;
END $$;
